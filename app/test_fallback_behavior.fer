// Test fallback return behavior - should show minimal errors

// This should be OK - has fallback return, no errors expected
fn testWithFallback(x: i32) -> i32 {
    if x > 0 {
        if x > 10 {
            // No return here, but fallback covers it
            let z: i32 = x * 2;
        } else {
            return x;
        }
    } else if x > -10 {
        // No return here either, but fallback covers it
        let y: i32 = x + 1;
    }
    // FALLBACK RETURN - should cover all missing paths above
    return x;
}

// This should show only specific branch errors - no fallback
fn testNoFallback(x: i32) -> i32 {
    if x > 0 {
        if x > 10 {
            // This specific branch should be highlighted
            let z: i32 = x * 2;
        } else {
            return x;
        }
    } else if x > -10 {
        // This specific branch should be highlighted
        let y: i32 = x + 1;
    } else {
        return x - 1;
    }
    // NO FALLBACK - should error for specific branches only
}

fn main() {
    let result1: i32 = testWithFallback(5);
    let result2: i32 = testNoFallback(15);
}


type Error interface {
    value() str;
}

type NetworkError struct {
    message: str,
    code: i32
};

fn (e NetworkError) value() str {
    return "Error " + e.message;
}

// fetch returns a string or an error
fn fetchData() -> str ! NetworkError {

    // dummy variable "dataAvailable" to simulate data availability
    if !dataAvailable {
        return @NetworkError { message: "Network failure", code: 500 }!;
    }

    return "payload"; // successful return
}

fn main() {

    // | value | { ... } is a closure that handles the error case for possible error return from functions
    let data := fetchData() | err | {
        print("Fetch failed: " + err.value());
    }

    print("Got: " + data);

    // Optional types use Type? syntax. Value can be of the type or None.
    // None is a constant representing absence of value.
    let maybeUser: str? = None;
    let name: str = maybeUser ?? "Guest"; // "??" operator provides a default value if the variable is None
    print("Hello, " + name);
}



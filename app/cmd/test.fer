
//let a := 10;  // This should be an error now

let p, q, r := 10, 12, 34;     // Type inference with :=
let x, y: i32 = 100, 200;     // Explicit types with =
let z: str;                    // Declaration only (no initialization)

const PI := 3.1416; 
fn add() {
    //later();
    let rad := PI * 2 ** 2;
}

// fn later() -> i32 {
//     return 0;
// }

fn search(keyword: str, callback: fn()) {
    callback();
}

const later := fn() -> i32 {
    return 0;
};

// comment
//let x := a + ;


// type Point struct {
//     .x: i32,
//     .y: i32
// };

// let p := Point { .x = 12, .y = 38 };

// print(p.x)

// -------------------

// type Point struct {
//     x: i32,
//     y: i32
// };

// let p := @Point { x: 12, y: 29 };


// // Optional types

// let res : str?; // string or None
// res = "hello"; // valid
// res = None; // valid

// let data: str = res ?? "No value"; // if res is None, assign "No value" to data

// // if res != None {
// //     print(res);
// // } else {
// //     print("no value");
// // }

// // Error return from functions
// fn mayFail() -> str ! {
//     if dataAvalable {
//         return "Data";
//     } else {
//         return "Error occurred"!;
//     }
// }

// let result: str = mayFail() | error | {
//     print("Handling error: " + error);
//     return;
// }
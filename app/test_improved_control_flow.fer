// Test improved control flow - should be less strict

// This should be OK - has fallback return after if
fn testWithFallback(x: i32) -> i32 {
    if x > 0 {
        return x * 2;
    }
    // Fallback return - this is fine
    return x;
}

// This should still error - no fallback
fn testNoFallback(x: i32) -> i32 {
    if x > 0 {
        return x * 2;
    }
    // Missing return when x <= 0 and no fallback
}

// This should be OK - complete if-else
fn testCompleteIfElse(x: i32) -> i32 {
    if x > 0 {
        return x * 2;
    } else {
        return x;
    }
}

// This should error - incomplete if-else
fn testIncompleteIfElse(x: i32) -> i32 {
    if x > 0 {
        return x * 2;
    } else if x > -10 {
        // Missing return in this branch
        let y: i32 = x + 1;
    } else {
        if x < -20 {
            //return x * 3;
        }
        //return x;
    }
    // Missing fallback return
}

fn main() {
    let result1: i32 = testWithFallback(5);
    let result2: i32 = testCompleteIfElse(3);
}

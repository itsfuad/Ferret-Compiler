// Test advanced struct casting scenarios
type Point2D struct {
    x: i32,
    y: i32
};

type Point3D struct {
    x: i32,
    y: i32,
    z: i32
};

type ExtendedPoint struct {
    x: i32,
    y: i32,
    color: str
};

fn main() {
    // Valid: Point3D has all Point2D fields + more (structural subtyping)
    let point3d: Point3D = @Point3D{x: 1, y: 2, z: 3};
    let point2d: Point2D = point3d as Point2D;
    
    // Valid: ExtendedPoint has all Point2D fields + more 
    let extPoint: ExtendedPoint = @ExtendedPoint{x: 5, y: 6, color: "red"};
    let basicPoint: Point2D = extPoint as Point2D;
    
    // Valid: Named to anonymous with matching fields
    let anonPoint = point2d as struct{x: i32, y: i32};
    
    // Valid: Anonymous to named with matching fields
    let anonSource = @struct{x: 10, y: 20, extra: "data"};
    let namedDest: Point2D = anonSource as Point2D; // extra field ignored
    
    // Test field access
    let x1: i32 = point2d.x;
    let y1: i32 = basicPoint.y;
    let x2: i32 = anonPoint.x;
    let y2: i32 = namedDest.y;

    let char = 'a';
    let strValue: str = "Hello, Ferret!";
    //let charToStr: str = char as str; // Implicit cast from char to str
    let i32Value: i32 = 42;
    let uintValue: u32 = i32Value as u32; // Implicit cast from i32 to u32
    let floatValue: f64 = 3.14;
    let floatToInt: i32 = floatValue as i32; // Implicit cast from f64 to i32
    let intToFloat: f64 = i32Value as f64; // Implicit cast from i32 to f64
    //let strToChar: byte = strValue[0] as byte; // Implicit cast from str to byte
    let byteToUint: u8 = char as u8; // Implicit cast from byte to u8
    let byteToFloat: f32 = char as f32; // Implicit cast from byte to f32
}

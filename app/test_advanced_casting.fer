// Test advanced struct casting scenarios
type Point2D struct {
    x: i32,
    y: i32
};

type Point3D struct {
    x: i32,
    y: i32,
    z: i32
};

type ExtendedPoint struct {
    x: i32,
    y: i32,
    color: str
};

fn main() {
    // Valid: Point3D has all Point2D fields + more (structural subtyping)
    let point3d: Point3D = @Point3D{x: 1, y: 2, z: 3};
    let point2d: Point2D = point3d as Point2D;
    
    // Valid: ExtendedPoint has all Point2D fields + more 
    let extPoint: ExtendedPoint = @ExtendedPoint{x: 5, y: 6, color: "red"};
    let basicPoint: Point2D = extPoint as Point2D;
    
    // Valid: Named to anonymous with matching fields
    let anonPoint = point2d as struct{x: i32, y: i32};
    
    // Valid: Anonymous to named with matching fields
    let anonSource = @struct{x: 10, y: 20, extra: "data"};
    let namedDest: Point2D = anonSource as Point2D; // extra field ignored
    
    // Test field access
    let x1: i32 = point2d.x;
    let y1: i32 = basicPoint.y;
    let x2: i32 = anonPoint.x;
    let y2: i32 = namedDest.y;
}

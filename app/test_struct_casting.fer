// Test struct casting functionality
type Point struct {
    x: i32,
    y: i32
};

fn (p: Point) getPointX() -> i32 {
    return p.x;
}

type Point3D struct {
    x: i32,
    y: i32, 
    z: i32
};

fn (p: Point3D) getPoint3DX() -> i32 {
    return p.x;
}

fn main() {
    // Named to Anonymous casting - should work if all fields match
    let namedPoint: Point = @Point{x: 10, y: 20};
    let anonFromNamed = namedPoint as struct{x: i32, y: i32};
    
    // Anonymous to Named casting - should work if all fields match  
    let anonPoint = @struct{x: 30, y: 40};
    let namedFromAnon: Point = anonPoint as Point;
    
    // Named to Named casting (structural subtyping)
    let point3d: Point3D = @Point3D{x: 1, y: 2, z: 3};
    let point2d: Point3D = point3d as Point; // Point3D has all Point fields + more

    point2d.getPointX(); // Method call works, returns x value
    //point2d.getPoint3DX(); // Method call works, returns x value from Point3D
    
    // Test field access after casting
    let x1: i32 = anonFromNamed.x;
    let y1: i32 = namedFromAnon.y;
    let x2: i32 = point2d.x;
}
